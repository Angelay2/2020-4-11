tcp:    
    创建套接字
    绑定地址信息
    监听
    获取新连接
    接收和发送数据
    关闭套接字
    连接接口
EpollSvr接口封装:
    创建epoll操作句柄 epoll_create
    添加对应事件结构到epoll当中  epoll_ctl
    从epoll当中删除对应的事件结构  epoll_ctl
    监控   epoll_wait
    
    成员变量: 
        需要保存epoll的操作句柄

epoll对描述符就绪事件的触发方式
    水平触发:
        EPOLLLT ---> epoll的默认工作方式, select和poll都是水平触发水平; (喊吃饭了, 一直没去, 一直过来叫)
        可读事件:
            只要接收缓冲区当中数据大于低水位标记(1字节), 就会一直触发可读事件就绪, 直到接收缓冲区当中没有数据可读(接收缓冲区当中的数据低于低水位标记)
        可写事件:
            只要发送缓冲区当中的空间大小大于低水位标记(1字节), 就会一直触发可写事件就绪, 直到缓冲区当中没有空间可写

    边缘触发(边沿触发) : (喊吃饭, 只叫一次, 就不来了)
        EPOLLET ---> 只有epoll拥有
        设置: 
            在设置文件描述符对应的事件结构时, 只需要在事件结构当中关心的事件变量中按位或上EPOLLET就可以了
                struct epoll_event ev; 
                ev.events = EPOLLIN | EPOLLET (当我们有可读事件时, 只通知一次,不管你读完还是没读完,都不会通知你了,直到到新数据来的时候, 才会触发可读, 再次通知, )
        可读事件:
            每次到来一个新的数据, 只会通知一次, 如果应用程序没有将接受缓冲区当中的数据读完或者读走, 也不会通知, 直到新的数据到来, 才会触发可读事件, 如果触发可读事件, 尽量将数据读完, 否则后面就没有机会了
        可写事件:
            只有当发送缓冲区当中剩余空间从不可写变成可写的时候才会触发一次可写事件就绪;

    对于ET模式而言, 如果就绪事件产生, 那我们一定要把握好机会, 对可读事件将数据读完, 对于可写事件将数据写完;


判断recv的返回值, 和准备的buf实际接收字节的大小, 
    recv返回值 = 准备的buf的实际接收字节的大小
    有可能接收完了 
    有可能没接收完    不知道到底读完还是没有读完, 所以需要再去读一下
    recv的返回值 < 准备的部分实际接收字节的大小
        一定接收缓冲区当中没有数据了, 接收完了

将描述符设置为非阻塞的接口:
    int fcntl(int fd, int cmd, ...);
    1. 获取当前文件描述符的属性
        cmd: F_GETFL
    2. 将非阻塞属性设置到文件描述符的属性当中(O_NONBLOCK) 设置文件为非阻塞属性
        cmd: F_SETFL
        当文件描述符设置成为非阻塞的时候, 当接收缓冲区当中没有数据, 还去调用recv, 则会报错并返回
            EWOUNDBLOCK或者EAGAIN ---> 一定要特殊处理这种情况, 认为这种情况是接收完了 直接break掉

ET :
    1. 结合了循环将数据进行发送和读取, 判断读完/写完
    2. 需要将文件描述符设置成为非阻塞
占用的资源小了, 效率高了, 
