进程控制:
    1. 进程创建
     vfork:
        功能:创建子进程
        创建出来的子进程空间饿父进程共用一份; 如果父子进程同时并行运行 有可能导致调用栈混乱的问题,
        vfork解决方案: 让子进程先运行, 子进程运行完毕后,再让父进程运行
        <<UNIX环境高级编程>>
    2. 进程终止
        正常:
            main函数代码执行完毕,但是结果正确
            main函数代码执行完毕, 但是结果错误
            三种方式:
                main函数的return返回; exit函数:(库函数); _exit函数:(系统调用)
                exit函数比_exit函数多两个步骤终止进程: 
                    第一步: 执行自定义处理函数
                    第二步:刷新缓冲区
                刷新缓冲区的方式: main函数return返回; \n; fflush函数; exit函数
        异常
            代码没有执行完毕, 程序崩溃掉了(解引用空指针; 内存访问越界, double free; "crtl+c"; "kill命令")
    3. 进程等待
        作用:防止僵尸进程的产生
        pid_t wait(int* status): 第一个字节, 第二个字节, 第三个字节, 第四个字节
            status: 该参数是一个出参,占用了4个字节, 实际有效部分为2个字节(后面低两个字节) 倒数第二个字节为退出码
                进程正常退出:
                    高16位当中高8位代表退出码, 16位当中低8位全为0
                    获取退出码: (status >> 8) & 0xFF 向右移动8位变为低8位 再&0XFF, 可以看到哪一个位为1
                进程异常退出:
                    16位当低8位被划分为2个部分, 第8位和第7位: 第8位代表coredump标志位; 第7位为终止信号
                    获取coredump标志位: (status >> 7) & 0x1  有1则产生了coredump文件 为0则没有产生
                    获取终止信号: status & 0x7f 
            wait函数时阻塞等待: 谁调用谁阻塞等待, 直到有子进程退出,才返回
            pid waitpid(pid_pid, int* status, int options)
                pid: 等待进程的pid号 不仅仅可以传入pid号 还可以传入-1
                    -1: 等待任意子进程
                    >0: 等待进程号为pid的子进程
                options:
                    0: 表阻塞
                    WNOHANG: 代表非阻塞(当我们调用函数时 需要等待条件成熟 如果不成熟 直接报错返回)
            返回值: 
                 非阻塞模式: 
                    返回0, 则表示没有等待到子进程, 需要循环调用; 
                    -1表返回错误; 
                    大于0才表示等待到了子进程
    如果进程退出的时候, 返回-1, 则退出码取到多少?    --> 255
       1: 正数在计算机中的存储方式: 正数的反码就是本身 补码也是本身
           正数原码:  00000001
           正数反码:  00000001
           正数补码:  00000001
     正数和负数: 最高符号位 正数为0, 负数为1,
       -1: 负数的反码就是将原码0变1 1变0, 符号位不动; 补码是反码加1
            负数原码: 10000001
            负数反码: 11111110
            负数补码: 11111111
    为什么返回的是一个int类型 但是最终计算出来的结果是255
        就是由于退出码在内核中只占用了1个字节


进程程序替换:
    1. 原理
        创建进程同时创建一个结构体task_struct, 结构体的内存指针指向进程虚拟地址空间(并不具备存储数据的能力, 真正存储数据是在物理内存中) 物理内存的数据来源于磁盘(test可执行程序被执行后, 数据/代码加载到物理内存), 通过页表映射到进程虚拟地址空间的数据段/代码段
        进程程序替换: 是想要用新程序的数据段和代码段替换正在运行的程序的数据段和代码段, 更新堆,栈 ( 促使重新加载可执行程序到物理内存中 ) 进程pid号没有改变只是执行的数据段和代码段变了而已  命令行参数和环境变量也不改变
    2. 进程程序替换接口:
        exec函数簇: 不是一个函数, 而是多个函数
        int execl(const char* path(要替换哪一个可执行程序), const char* arg(名称), ...)
            path: 带路径的可执行程序
            arg: 给可执行程序传递的参数, 规定: 第一个参数必须是可执行程序的名称
            ...: 可变参数列表, 必须以NULL结尾, 告诉execl函数读到NULL的时候就是命令行参数结尾地方
            execl("usr/bin/ls", "ls", "-a", NULL);
            返回值: 

    int execlp(const char* file, const char* arg, ...)
        file: 可执行程序的名称,由于可执行程序没有带路径, 所以这个可执行程序是必须在环境变量PATH当中可以找到的 用$PATH查看 用export将要执行的程序路径临时插入PATH后;   也可以直接将可执行程序的绝对路径放在可执行程序的名称前面

    int execle(const char* file)




        



