   系统编程之进程的概念
   1. 冯诺依曼体系结构 
   二进制: 所有数据都是按照二进制的方式进行存储
       内存存储: 数据都是交给存储器设备进行设备
        中央处理器(CPU), 存储器(内存), 输入设备, 输出设备
    2. 操作系统
        操作系统是一个软件
        操作系统 = 操作系统内核 + 一组应用
        操作系统内核是用来管理计算机软硬件资源
        管理 = 描述(struct) + 组织(struct->struct->struct)
        硬件设备 +  驱动程序(鼠标驱动) + 
    3. 进程概念 
       1. 程序和进程的区别 
       程序: 本质上就是一个文件, 文件是通过编译产生的可执行文件
//        进程: 进程是程序执行起来的一种表现形式, 进程是操作系统分配资源的最小单位
//       2. 操作系统是如何来管理进程
//        描述:
//            进程控制块: process control block. 操作系统来描述进程的数据结构
//            进程控制块<==>PCB<==>struct task_struct(sched.h)
//            struct task_struct:
//                进程标识符: 别名进程号, 别名进程pid,用来标识一个进程; 在用一个操作系统当中pid是不能重复的;
//                  ps aux可以查看当前操作系统党总的进程信息; pa aux|grep[xxx]
//                  以进程pid命名的进程文件夹(在/proa/[pid]文件夹下), /proc/[pid]/fd这个文件夹里当前进程打开的文件信息, 称为文件句柄,
//                  前台进程&后台进程:
//                  kill命令: kill[pid] 可以结束前台或后台的进程 并不能杀死暂停状态下的进程 需为kill -9[pid]
//                进程状态:   
//                   阻塞(等待IO进入), 运行, 就绪
//                   R: 运行状态
//                   S: 可中段睡眠状态
//                   D: 磁盘睡眠状态 死了等复活(不可以被打断)
//                   T: 暂停状态 crtl+Z可以进入暂停状态,使用kill[pid]并不能杀死在暂停状态的进程, 要使用kill -9 [pid](强杀)
//                   t: 跟踪状态 gdb调试时会产生,
//                   X: 死亡状态 内核释放进程时会调这个状态
//                   Z: 僵尸状态 
//
//            程序计数器: 保存进程即将要执行的下一条指令, 调试时在 disassemble 命令中可以看到
//            4核8C: 4个物理CPU 8个逻辑CPU
//            多个进程之间对于CPU而言是抢占式执行(茅坑)
//            第一种: 并发执行 多个进程使用一个CPU, 每个进程使用一小会 换其他
//            第二种: 并行 多个进程每一个进程都占一个CPU进行运算, 并行的运行
//            上下文数据: 保存上次执行的时候, 寄存器当中的值(用来恢复(获得)寄存器的值)
//            内存指针: 指向进程地址空间, 
//            进程在占用CPU计算时, 时间是微秒, 纳秒计算
//            优先级: 相对于其他进程的优先级
//              PR(new) = PR(old) + NI(nice值) 影响new的PR值(更改进程的优先级--> 优先调动权), 但是会不会影响有操作系统决定,
//    组织: 内核使用双向链表来组织进程中的task_struct的信息
//    如何在代码中创建一个进程?
//    系统调用: pid_t getpid(void) 获取当前进程的pid接口
//   系统调用: int fork(); 用来创建进程
//      返回值: 
//     1. 成功返回子进程pid --> 这个分支是给父进程准备的
//     2. 成功返回0 --> 这个分支是给子进程准备的
//     3. 失败返回小于0的数 --> 
//    首先创建了父进程(有自己的PCB..)  fork()接口就是以父进程为模板拷贝成为了子进程(也是需要执行代码的)
//      fork返回值:
//      1. 返回大于0: 给父进程, 大于0的数, 是子进程的PCB,(子进程的名字就相当于pid,返还给父进程)
//      2. 返回等于0: 给子进程, 
//      3. 返回小于0: 失败
//    如果fork创建子进程(调用)成功, 则会返回两次值,一次返回大于0(子进程PCB). 一次等于0()
//      可以使用分支语句去区分父子进程执行不同的逻辑

    僵尸状态的产生原因:
     由于子进程退出, 但是父进程来不及回收子进程的退出资源, 而导致子进程变成僵尸状态
     究其根本: 由于子进程的PCB并没有给内核, 释放这样的PCB需要父进程来进行回收, 
     使用ps aux | grep [xxx]可以查看进程信息发现子进程变成了僵尸状态
    危害:
      泄漏了操作系统的资源, 僵尸进程的PCB并没有被释放掉, task_struct(结构体)



    孤儿进程: 父进程先于子进程退出, 子进程被1号进程所领养, (为了当子进程退出的时候, 回收子进程的退出信息, )
    1号进程: 操作系统启动的第一个进程, 好多进程都是被1号进程所创建的
    进程是有僵尸状态的, 但是没有孤儿状态

    孤儿杀养父, 完了后就全部死光了, 
    僵尸进程如何回收:
        1. 杀死僵尸进程的父进程(父进程被杀掉, 相当于僵尸进程变成了孤儿进程, 孤儿进程又会被1号进程所回收, 就没有僵尸进程了)
        僵尸进程是死的 用kill命令杀不死, 但是孤儿进程是活的 ,可以用kill -9 pid杀死
        2. 后面会有进程等待 也会解决僵尸进程的问题



