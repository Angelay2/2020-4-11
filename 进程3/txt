    孤儿进程:  1号进程被称为Init进程 1号进程会在子进程退出的时候 回收子进程的退出信息, 防止子进程变成僵尸进程
   代码共享: 由于在子进程拷贝了父进程的PCB, 换句话说, 也就是将PCB当中内存指针指向的程序地址空间当中的代码段也拷贝了. 所以父子进程对于代码段是一模一样的, 我们可以通过fork的返回值,来让父子进程执行不同的逻辑
   数据独有: 由于父子进程各有自己的程序地址空间, 所以
   每一个结构体task_struct都是双向链表(内核)的一个元素    
    ps aux|grep [xxx]
    两个都是查看进程信息 只是显示内容的多少不一样
    ps aux|head -n 1
    pa -ef|head -n 1

环境变量:
    是用来定义系统运行环境的一些参数,比如说; 每一个用户的家目录,
    常见的环境变量:
        HOME(环境变量名称): 保存用户家目录的环境变量
        SHELL: 保存才能当前使用的 命令行解释器的名称
        PATH: 保存可执行程序的路径的环境变量
        LD_LIBRARY_PATH: 程序运行时, 依赖库文件的搜索路径的环境变量, 动态库环境变量名称
        CPLUS_INCLUDE_PATH: 可以定义第三方C++头文件所在路径的环境变量
    常见命令:
        echo $[环境变量名称]: 可以查看某一个环境变量的值(内容)
        env: 查看当前操作系统当中环境变量的名称和环境变量的值\
        export: 可以更改或者增加环境变量(但是他的效果只是暂时的  关闭掉当前窗口后 就没作用了)
            export[环境变量名称] = $[环境变量名称]:[新加的环境变量的值]
            export PATH=$PATH:现在的路径
            export PATH=现在的路径 (会让其他的命令失效, 但是关闭掉当前窗口后 新开一个 又可以用了)
                $HOME就是/home/Angelay2
        永久生效:(直接将更改的环境变量内容写入系统环境变量文件中, 每次重新打开一个终端时, 操作系统就会帮助我们加载环境变量文件, 从而更改的环境变量内容也被加载到系统环境变量当中去了)
            1. 需要先去了解环境变量配置文件名称
             普通用户而言: 有自己的环境变量 并且还受系统的环境变量影响
                            用户环境变量 = 系统环境变量 + 用户自定义的环境变量
                系统环境变量: etc/bashrc
                当前用户环境变量:
                   ~/.bashrc
                   ~/.bash_profile
                改了之后 需要source ~/.bash_profile 来重新加载当前所改动环境变量文件(刷新) 就可以永久生效了
                   重新打开一个新的终端 也会重新加载所有的环境变量文件
            环境变量名称一般都是大写
        char* env[] -->  (所有环境变量值放到一个数组中 最后一个是以NULL结束的,)

        内存指针指向程序地址空间 对于32位系统, 地址空间是4G, 有1G的空间是被内核空间占用, 接下来是命令行参数&环境变量区 接下来是栈
        0xffff ffff(高地址) --> 0xC000 0000(内核空间的尾地址) --> 0x0000 0000(低地址)

        内核调用main函数, 在内核中创建task_struct这个结构体时 就已经把所有的命令行参数&环境变量都已经写好了 至于你要不要 我都有
        同样有一个函数来调用main函数, 
         
        虚拟地址是程序员虚拟出来的逻辑地址 不是物理地址, 是为了更好滴去利用我们的物理内存, 
        虚拟地址通过页表映射到物理内存中找到对应的值
        创建子进程时(拷贝时)也会拷贝页表(映射关系), 所以父子进程计算的结果是一样的, (两个虚拟地址映射的是物理内存中的同一个值)
        若改变进程中的变量计算, 则会在物理内存中重新申请一块空间来存放新的计算结构
           1. 当创建一个子进程时, 子进程会拷贝父进程的页表结构, 也就是说会将父进程虚拟地址空间和物理内存之间的映射关系也拷贝了
           2. 如果创建完成一个子进程, 子进程也会通过页表映射到物理内存的同一块区域
           3. 如果父子进程都不进行修改, 则映射关系也不会修改,(写时拷贝技术), 和平共处,访问同一块物理内存, 
           4. 如果有一个进行了修改, 则就不能同时访问同一块物理内存, 需要重新去开辟空间, 同时修改改动进程的映射关系, 
           
         进程虚拟地址 = 页号 + 页内偏移
         页号: 进程会将虚拟地址空间分成一页一页的结构          
         块号: 物理内存分为不同的块,每一个块都有一个块号,       
         页的大小 = 块的大小 
         通过页号找到块号 通过块号找到其在物理内存中的具体的块, 通过页内偏移找到再这个块中的具体位置

         1. 虚拟地址 = 页号 + 页内偏移
            页号 = 地址大小/块的大小
            页内偏移 = 地址大小 % 块的大小
         2. 物理地址
            页号 -->找到 块号
            块的起始地址 = 块号 * 块的大小
            物理地址 = 块的起始地址 + 页内偏移

