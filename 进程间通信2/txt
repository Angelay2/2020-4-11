每个进程都拥有自己的独立的虚拟地址空间和页表结构, 所以每个进程是独立的, 进程间必须借助媒介来进行通信
这些媒介包括管道, 共享内存 消息队列 和信号量
    匿名管道(在内核中创建的这块缓冲区并没有一个标识), 但是内核会返回给我们用户两个文件描述符(fd[0]缓冲区的读端, fd[1]缓冲区的写端),
    创建匿名管道的接口 int pipe(int fd[2])
        fd[2] : 具有两个元素的整形数组, 包括fd[0], fd[1],
        接口返回值有两 返回0 表示创建成功; 返回-1(也就是小于0)表示失败

        由于这段缓冲区没有标识, 而对于没有关系的两个进程 想要通过这个缓冲区来进行数据交换时, 不同的进程是找不到这片缓冲区的, 
    无法去修改缓冲区中的内容, 所以也就无法进行数据交换, -------> 所以匿名管道只适合具有亲缘关系的进程之间, 
        父进程先去创建一个管道, 然后在父进程的文件描述表files_struct中就有fd[0]和fd[1], 分别对应3号和4号文件描述符, 
        然后再创建出来子进程, 由于子进程会拷贝父进程的PCB, 所以文件描述表也被拷了, 所以在子进程中也有了fd[0], fd[1],也对应他的3,4文件描述符,   这时候父子进程就可以通过操作文件描述符来操作缓冲区, 
        同时匿名管道又是一个半双工的, 数据流向只能是从写端流到读端(like水管), 
        加上每次将字节写入到缓冲区后, 数据之间时没有明确的数据边界的, 所以在读端读的时候, 他可以按自己的需求读任意个数的字节,也就是任意大小的数据, 且管道大小(PIPE_SIZE)为64K, 所以会出现两种情况
        1. 当读端不读, 写端一直写的时候, 而当管道被写满时, 就会造成写端的阻塞, 
        2. 当写端不写, 读端却一直读时, 而当管道为空的时候, 就会造成读端的阻塞, 
        同时在创建匿名管道时 返回的文件描述符的属性 默认是阻塞属性, 
        而fcntl这个接口可以修改阻塞属性, 将其变为非阻塞属性 int fcntl(int fd, int cmd, ...)
            这里的fd是我们想要更改属性的文件描述符, cmd是操作(获取属性和设置属性), 可变参数列表(传递最终要变成的属性数据)
            可变参数只有在设置(F_SETFL)的时候才写, 而获取(F_GETFL)属性数据时不用写
            要想设置为非阻塞属性, 得先获取当前属性数据, 然后按位或O_NONBLOCK, 将按位或之后的数据作为可变参数列表传递 设置属性即可
           vim /user/include/bits/fcntl-linux.h文件当中可以查看属性的定义
           fd[0]其实只是设置了O_RDONLY, fd[1]只是设置了O_WRONLY  而O_NONBLOCK的二进制为 16个0 00001000 00000000(倒数第12位为1)
        设置文件描述符为非阻塞属性之后, 还有两种情况:
            1. 不进行读, 但是一直写; 设置写端的文件描述符为非阻塞属性, 不用设置读端文件描述符, 因为没有用
                1.1 读端不关闭, 写端一直写, write返回-1, 报错当前资源不可用 
                1.2 读端直接关闭, 写端一直写, 当前的进程会受到SIGPIPE信号, 代指写端程序直接被杀死, 管道破裂, 
            2. 不进行写, 一直读; 只需要将读端的文件描述符设置为非阻塞属性, 不用设置写端, 因为不用
                2.1 写端不关闭, 读端一直读, read调用返回-1. 返回资源不可用
                2.2 所有写端关闭, 读端进行读, read是正常调用的, read返回的是读到的字节数据
    匿名管道的特性: 往匿名管道里写操作是以追加方式写的, 不会覆盖,
        1. 管道大小(PIPE_SIZE)为64K;
        2. PIPE_BUF: 4K, 当我们读写的数据小于PIPE_BUF(4K)时, 保证读写的原子性(当前只允许一个进程访问 ,不会被打断)
            内存和CPU交换数据, 两进程跑起来后, 都会将自己的代码和或使用的数据加载到内存中去, 若两者同时都想修该内存中的buffer(匿名管道), 当buffer大小 < 要写的数据大小时, 会被打断 截断, 最终读到的数据是不连续的,  
            并行: 不同的进程拿着不同的CPU,同时进行计算
            并发: 不同的进程在不同的时刻 拿着同样一个CPU进行运算

        原子性: 当前操作不能被打断, 不论是读, 还是写操作都不能被打断; 引申 --> 当前操作要么是完成了, 要么一定没有完成, 不存在走一半的情况
        临界资源: 
            同一时间时刻, 当前的资源是能被一个进程所访问, 前提是当前写入的数据是小于buffer大小(4K)的; 如果多个进程同时修改临界资源, 可能会导致数据二义性
         问题: 如何保证对临界资源访问的合理性, 不会造成数据二义性呢
            互斥: 同一时间, 保证只能有一个进程访问临界资源(厕所加门)
            同步: 保证了进程被临界资源访问的合理性(防止等厕所时间过长 里面的人故意不出来, 保证所有人都能上厕所, 留电话号码)


命名管道:
    1. 命名管道具有标识符, 内核创建的内存时有标识的; 不同的进程可以通过标识访问到命名管道, 可以支持不同进程之间进行通信
    2. 如何创建一个命名管道呢?
        使用命令创建: 
            mkfifo [命名管道的文件名称] 文件类型为p, p为管道文件(mkfifo fifo  --> fifo只是一个标识, fifo表示数据是先进先出的)
        使用函数创建
            int mkfifo(const char* pathname, mode_t mode);
                pathname: 带路径的命名管道文件名称
                mode: 权限
    3. 用户可以通过操作命名管道文件来对内核当中的命名管道的内存区域来进行操作
    4. 特性:
        具有标识符, 可以满足不同进程之间的进程间通信
        其他特性和匿名管道相同
    无论是匿名管道还是命名管道,生命周期都是跟随进程的; 进程退出了,buf也会被内存释放



        
