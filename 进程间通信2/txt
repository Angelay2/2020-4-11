每个进程都拥有自己的独立的虚拟地址空间和页表结构, 所以每个进程是独立的, 进程间必须借助媒介来进行通信
这些媒介包括管道, 共享内存 消息队列 和信号量
    匿名管道(在内核中创建的这块缓冲区并没有一个标识), 但是内核会返回给我们用户两个文件描述符(fd[0]缓冲区的读端, fd[1]缓冲区的写端),
    创建匿名管道的接口 int pipe(int fd[2])
        fd[2] : 具有两个元素的整形数组, 包括fd[0], fd[1],
        接口返回值有两 返回0 表示创建成功; 返回-1(也就是小于0)表示失败

        由于这段缓冲区没有标识, 而对于没有关系的两个进程 想要通过这个缓冲区来进行数据交换时, 不同的进程是找不到这片缓冲区的, 
    无法去修改缓冲区中的内容, 所以也就无法进行数据交换, -------> 所以匿名管道只适合具有亲缘关系的进程之间, 
        父进程先去创建一个管道, 然后在父进程的文件描述表files_struct中就有fd[0]和fd[1], 分别对应3号和4号文件描述符, 
        然后再创建出来子进程, 由于子进程会拷贝父进程的PCB, 所以文件描述表也被拷了, 所以在子进程中也有了fd[0], fd[1],也对应他的3,4文件描述符,   这时候父子进程就可以通过操作文件描述符来操作缓冲区, 
        同时匿名管道又是一个半双工的, 数据流向只能是从写端流到读端(like水管), 
        加上每次将字节写入到缓冲区后, 数据之间时没有明确的数据边界的, 所以在读端读的时候, 他可以按自己的需求读任意个数的字节,也就是任意大小的数据, 且管道大小(PIPE_SIZE)为64K, 所以会出现两种情况
        1. 当读端不读, 写端一直写的时候, 而当管道被写满时, 就会造成写端的阻塞, 
        2. 当写端不写, 读端却一直读时, 而当管道为空的时候, 就会造成读端的阻塞, 
        在创建匿名管道时 返回的文件描述符的属性 默认是阻塞属性, 
        而fcntl这个接口可以修改阻塞属性, 将其变为非阻塞属性 int fcntl(int fd, int cmd, ...)
            这里的fd是我们想要更改属性的文件描述符, cmd是操作(获取属性和设置属性), 可变参数列表(传递最终要变成的属性数据)
            可变参数只有在设置(F_SETFL)的时候才写, 而获取(F_GETFL)属性数据时不用写
            要想设置为非阻塞属性, 得先获取当前属性, 然后将当前属性按位或上O_NONBLOCK,然后将结果作为可变参数列表, 最终将当前的文件描述符修改为可变参数列表的数据

        针对上面的两种情况, 现在把文件属性设置为非阻塞属性 也有两种情况(将写端设置为非阻塞和将读端设置为非阻塞)
             1. 不进行读, 但是一直去写, 设置写端的文件描述符为非阻塞属性, 不用设置读端文件描述符, 因为没有用到, 
              读端不读分读端关闭和读端不关闭两种情况          
                1.1 读端不关闭, 写端一直写, write会返回-1, 报错当前资源不可用,
                1.2 读端直接关闭掉, 写端还一直写, 当前进程收到了SIGPIPE信号(进程退出), 写端程序被杀死, 管道破裂
            2. 不写, 一直读; 只需将读端设置为非阻塞, 写端可以不用关心, 因为没有用到写端
              写端不写也分写端关闭和写端不关闭两种情况
                2.1 写端不关闭, 读端进行读, read调用返回-1, 返回资源不可用
                2.2 所有写端关闭, 读端进行读, read是正常调用的, read返回的是读到的字节数量
        匿名管道的特性:
            1. 管道的大小(PIPE_SIZE)为64K
            2. PIPE_BUF: 大小为4K, 当我们读写的数据小于PIPE_BUF时, 保证了我们读写的原子性; 以追加方式写 后面写的数据不会覆盖前面写的数据
            若两个进程同时想去修改匿名管段中的buf,想到并行(在多核CPU中可行)和并发;
                并行: 不同的进程拿着不同的CPU同时进行运算
                并发: 不同的进程在不同的时刻拿着同样的CPU进行运算
            假设我们这两个进程现在并发去修改BUF的内容, 若进程A写的资源是大于PIPE_BUF(4k)的,还没写完, 进程A就被强制退出CPU, 此时进程B就要去占用CPU往buf中写,写完之后进程B退出, 进程A继续将未写完的剩余数据往buf中写, 这样所看到的数据就是不连续的, 由于进程A中途被打断了
            而原子性: 就是指当前操作不能被打断, 不论是读还是写操作都不能被打断, 引申出来的含义就是, 当前操作要么是完成了, 要么就是没完成, 不可能有完成一半的情况. 被打断就意味着不能保证原子性. 
            临界资源: 同一时间, 当前的资源只能被一个进程所访问, 前提是写入或读取的数据必须是小于PIPE_BUF(4k); 如果多个进程同时去修改临界资源, 可能会导致数据二义性(造成数据不连续 不是想要的结果)
        问题: 如何保证对临界资源访问的合理性, 不会造成数据二义性呢?
            1. 多人都想去上同一个厕所, 如果同时进去就会导致数据二义性, 我们希望的结果是同一时刻, 只能有一个人在厕所里,所以给厕所装了门, 保证了同一时间只能有一个人在厕所;
            互斥: 同一时间, 保证只能有一个进程访问临界资源
            2. 但是现在又出现了另一种现象, 在厕所的人故意不出来, 导致其他的人永远都上不了厕所,也就意味着其他进程永远访问不了这块内存,这时其他人在厕所门口写上联系方式, 等里面的人出来了call他, 保证了所有人都能上厕所
            同步: 保证了进程对临界资源访问的合理性
         


命名管道: 
    1. 命名管道具有标识符, 内核创建的内存时有标识的, 不同的进程可以通过标识访问到命名管道
    2. 如何创建衣柜命名管道呢?
        使用命令创建: 
            mkfifo [命名管道的文件名称]    (名称其实是一个标识名称), 文件类型是p,p为管道文件
        使用函数创建
            int mkfifo(const char* pathname, mode_t mode);       
            包含在头文件 <sys/stat.h>
            pathname: 管道路径, mode: 权限
    3. 用户可以通过操作命名管道文件来对内核当中的命名管道的内存区域进行读写操作
    4. 特性
        具有标识符, 可以满足不同进程之间的进程间通信
        其他特性和匿名管道相同

   注意: 不论是我们的 匿名管道还是命名管道, 生命周期都是跟随进程的



共享内存:
    1. 共享内存的原理:
        在物理内存中开辟了一段地址空间, 









        
