C/S架构:
B/S架构:

微服务架构:
 将所有的自服务进行拆分, 每一个都是一个单独的服务对外开放
 支付宝    -----    1. 扫二维码 
                    2. 填写金额 
                    3. 转账 
                        1. 判断该账户是否有钱
                        2. 判断银行卡是否有钱
                        3. 账户有钱 ---> 账户扣除

单例模式: 
    1. 特点: 全局提供唯一一个类的实例, 具有全局变量的特点
    2. 应用场景: 内存池, 数据池  (提前向操作系统申请的, 还的时候还给池,)  -------  提高程序运行效率
    3. 基础要点:
        全局只有唯一一个实例   ---> static + 禁止构造(包括拷贝构造,赋值构造)  防止产生其他东西
        线程安全: 
            调用者提高单例类的函数来获取实例:
    4. 具体实现:
        饿汉模式   ---->   每次吃完饭, 就洗掉碗, 后面在吃饭的时候就直接拿来用
            当程序启动, 资源在初始化的时候, 已经全部加载完毕了
                优点: 程序运行速度很快,流畅
                缺点; 程序的初始化耗时比较长
        懒汉模式   ---->   每次吃完饭, 都不洗碗, 等到下次吃饭的时候再来洗碗
            资源在使用的时候, 才进行实例化
                优点: 程序初始化的时候比较快
                缺点: 运行的时候没有饿汉模式流畅
                      牵扯到线程安全(有可能有多个执行流对资源进行请求, 都对资源进行实例化, )
懒汉模式实现代码
class sigonten{
    public:
        static sigonten* GetInstance(); // 静态成员函数, 在类外初始化
    private:
        volatile static sigonten* p; // volatile: 防止编译器过度优化 (保存变量内存可见性)
}

// 全局只有一个单例的实例化对象, 多个执行流来进行实例化
static sigonten* GetInstance(){
    // 这下就不用让所有执行流进行等待了
    if(p == NULL){
        // 再来进行加锁操作
        // 对实例化进行加锁
        pthread_mutex_lock(&lock_);
        if(p == NULL){
            p = new sigonten();  // 实例化
        }
        pthread_mutex_unlock(&lock_);

      }   
   }
    // p != NULL , 就直接返回
    return p;  // p已经有了, 就不需要再进行实例化了
}

注意点:
    1. 双if判断
    2. 互斥锁保证线程安全
    3. volatile: 防止编译器过度优化 (保存变量内存可见性)

