网络:
    网络基础1 ---> 协议分层 + 封装与分用
    socket编程  --->  简单ip地址 + 网络字节序 + UDP套接字编程 + tcp套接字编程 + tcp多进程编程 + tcp多线程编程
    网络基础2 ----> 应用层 + 传输层
    网络基础3 ----> 网络层 + 数据链路层

网络基础1:
    1. 网络发展背景  
        网络起源于军事 --> 计算导弹的运行轨迹 --> 
        网络就是信息共享和信息交换的
    2. 网络覆盖范围 --- 是按覆盖面积划分的
        局域网(几到几十)
        城域网(几十到)
        广域网(多个城域网)
    3. 网络协议:
        协议: 通信双方对于通信的约定,使用同一种语言来进行有效沟通
        网络协议: 在网络当中通信双方对数据交换和数据传输做出约定
        协议簇: 计算机当中是由很多协议的, 讲很多网络协议练习在一起, 称之为协议簇
        参考模型或体系结构: 在协议簇当中, 定义了各个协议之间的相互关系和协议需要完成的任务

    4. 协议分层
        协议分层是一种封装, 对不同的协议或者服务进行封装
        OSI参考模型: 参考意义, 在工业上是并没有使用的, 因为分层太细了
            物数网传会表应:
            物理层, 数据链路层, 网络层, 传输层, 会话层, 表示层, 应用层
        TCP/IP模型
            物理层, 数据链路层, 网络层, 传输层, 应用层                        !!!!!我们之前写的代码都是在应用层写的
    不同的层在做什么事情????????????
        应用层:负责应用层数据之间的传输
            典型的协议: HTTP协议, FTP协议(rz命令), DNS协议, SMTP协议
        传输层: 负责端与端之间的 传输, 关心的只是端口, 从哪一个进程来要去到哪一个进程
            典型协议: TCP协议, UDP协议

         
        端口相关知识:   
            IP地址: 用来标识在网络当中的一台机器, uint32_t整数, 范围是0-42亿
            PORT: 端口, 在一台主机当中标识一个进程, 一个端口只能被一个进程所占用, 一个进程可以占用多个端口
                无符号的16位的整数 uint16_t整数 0~65536
            端口网络通信当中, 一条数据当中具有一个五元组信息(和快递很相似)
            源IP: 当前这个数据是从哪个机器上来的
            目的IP: 当前这个数据要去往哪个机器
            源端口: 从源主机上面哪一个进程来的, 当回复应答的时候, 就知道回复哪一个进程了
            目的端口: 去往哪一个主机上面的进程
            协议: protocol, 标识使用什么协议

    快递单      收件人信息
                    xxxx西安科技大学(目的IP)
                        y2收(目的端口) 
                                             寄件人信息
                                                    西安工程大学(源IP)
                                                        张三寄(源端口)
        协议: 顺丰快递/圆通
        当发现东西不对需要返还时, 交换信息
        知名端口: (0~1023), 被知名协议所占用
            http协议: 80
            https: 443
            ssh: 22
            mysql: 3306
            oracle: 1521
        我们自己在开发应用程序时, 杜绝占用知名端口, 尽量避免使用熟知软件使用的端口
        一个端口只能被一个进程所占用


        网络层: 负责地址管理和路由选择
            典型协议: IP协议, ICMP协议, 
            典型的设备: 路由器
        数据链路层: 负责相邻设备之间的数据帧传输
            典型协议: 以太网协议, 
            典型的设备: 交换机
        物理层: 负责光电信号的传输
            典型协议: 以太网协议
            典型的设备: 集线器

数据的封装:(除了应用层, 其他层都是网络协议栈完成的事情)
    应用层(程序员工作在此): 数据要传输到对端, 先到传输层....
    传输层
    网络层
    数据链路层
    物理层
每递交给下一层, 加上对应层的包头, 最终通过物理层转换为光电信号传给对端
数据的分用:
    对端的物理层拿到数据, 把光电信号转化为二进制
    数据链路
    网络层
    传输层
    应用层
每到一层, 去掉该层的头部, 

IP协议分为两个版本, 
    ipv4 --> 正在使用的版本
    ipv6
    根源: ipv4版本的IP地址不够用. uint32_t (0~2^32(42亿))  人有60多亿  ----> 占4字节
    ipv6 --> uint128_t (0~2^128)      ----> 16字节
    由于ipv6是不向下兼容ipv4版本的IP地址的 , 对于之前使用ipv4版本开发的程序, 需要重新开发来支持ipv6
    172.12.32.33(用.分开 4个字节, ipv4)   -----> 这就是点分十进制

    MAC地址: 无符号6字节的整数, uint8_t addr[6]
        MAC地址是全世界唯一的, 在数据链路层进行应用, 相邻设备之间的传输使用MAC地址

客户端和服务端的概念是相对的
    客户端: 主动发起请求的一方, 称之为客户端
    服务端: 被动的在同一个位置上(端口)接收请求的一方, 称之为服务端
    对外提供服务的端口一般不要变化, 否则就要通知所有用户来改变端口, 就会非常麻烦

网络字节序
    字节序: CPU对内存当中的数据进行存取的顺序
    大端字节序: 低地址存放高位
    小端字节序: 低地址存放低位
    aa = 0x12345678 
        高位     低位 
    网络字节序其实就是大端字节序
        我们在网络传输过程中都需要遵循网络字节序
    主机字节序:
        机器实际的字节序
    字节序转化:
        大端字节序的机器转换网络字节序的时候, 无须作任何事情
        小端字节序的机器转换网络字节序的时候, 需要将小端转换为大端
            针对IP
                uint32_t htonl(uint32_t hostlong): 将32位主机字节序的转换为网络字节序
                    引申含义: 大端调用该接口什么事情都没干
                uint32_t ntohl(uint32_t netlong): 将32位网络字节序转换为32位主机字节序
           针对PORT 
                uint16_t htons(uint16_t hostshort): 将16位的主机字节序转换为网络字节序
                uint16_t ntohs(uint16_t netshort): 将16位网络字节序转换为16位主机字节序

        int _addr_t inet_addr(char*) ----- 接收点分十进制的IP地址, 将IP地址转换为uint32_t 整数, 并且将主机字节序转换为网络字节序
        char* inet_ntoa(struct in_addr in);  ---- 将网络字节序转化成为主机字节序, 并且转化为点分十进制的IP地址

TCP与UDP协议的区别: 
    TCP协议
        面向连接: TCP通信双方子啊发送数据之前, 需要先建立连接, 才可以发送数据
        可靠传输: 保证TCP数据包一定到达对端
        面向字节流: 对于TCP数据可以随意的存取, 每一条数据和每一条数据之间是没有数据间隔的
        应用层把数据发送到发送缓冲区的时候 123  456 ---> 123456(就像水龙头一样)  没有间隔, 无法区分是同一条还是不同条, 这个也是TCP粘包的万恶之源
        发送到接收缓冲区后, 可以随意地接收任意字节 
    
    UDP协议
        无连接: 在发送数据的时候, 不需要建立连接, 知道对端的IP和端口就可以直接发送数据了
        不可靠: 如果在网络传输当中, 数据包丢掉了, 那就丢掉了, 不保证一定到达对端
        面向数据报: UDP在发送数据的时候, 是整条数据进行交付的, 
        等123发送给网络层后, 456才能发送, 交付是有先后顺序; 接收时也有大小规定, 明确.  

UDP通信流程 & UDP编程接口
    1. UDP通信流程
      前期准备工作;  
        客户端(client):
            1. 创建套接字
            2. 绑定地址信息 ---> 不推荐搭建手动绑定地址信息

        服务端(server):
            1. 创建套接字. 本质上在内核就是一个结构体struct socket{...},含义是将创建出来的套接字和网卡建立联系
            2. 绑定地址信息: IP和端口(1024~65535)
                将端口和进程联系起来, PORT表面服务端进程在哪一个端口上侦听数据. IP表示服务端进程在哪一个网卡上面接收数据
      网络通信:
        客户端给服务端发送数据, 
        服务端给客户端回复应答
        1. 发送数据
        2. 接收数据
        3. 发送应答
        4. 接收应答
        5. 关闭套接字

