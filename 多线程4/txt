使用多线程实现生产者和消费者模型(是通过队列去打交道 不是直接打交道的)
    123规则: 1个场所(队列) + 2种角色 + 3种关系
    1个场所(队列): 线程安全的队列
    2种角色: 生产者和消费者, 通常是生产线程和消费线程
    3种关系: 生产者和生产者互斥, 消费者和消费者互斥, 生产者和消费者互斥+同步(我在生产的时候你不能进来消费 + 我生产完后通知消费者)

    优点: 
        可以解耦合: 生产者与消费者通过队列进行交互, 生产者值关心队列当中是否有空闲的结点, 消费者只关心队列当中是否有生产好的数据
        支持忙闲不均: 队列起到一个缓冲的作用, 可以先生产数据到队列当中, 消费者可以直接在队列当中消费(生产的东西全都放在队列中 等到消费者看见时 一次全拿走)
        支持并发: 队列起到一个缓冲的作用(生产者一次生产了好多, 生产者只顾自己生产, 不顾消费者是否消费)
        

Posix信号量 --> 既能保证同步 也能保证互斥
    1. 可以完成什么样的任务
            主要完成进程间或者线程间的同步与互斥功能
    2. 本质
        资源计数器 + PCB等待队列 + 等待和唤醒接口
        1. 对比条件变量多了一个资源计数器, 资源计数器是对临界资源的数量进行计数操作的
        2. 信号量通过资源计数器, 来判断当前资源是否可用,
            可用: 则可以获取资源进行访问
            不可用: 则阻塞在等待接口当中了

    3. 操作接口
        1. 定义
            sem_t: posix信号量的类型       eg: sem_t sem
        2. 初始化(比之前学的都重要)
            sem_init(sem_t* sem, int pshared, int value)
                sem: 传入信号量的地址
                pshared: 表示当前信号量是在进程间使用还是在线程间使用
                    0: 表在线程间
                        全局变量
                    1: 表在进程间
                        初始化为进程间时, 内核会创建一块共享内存来保存信号量的数据结构, 其中的资源计数器,PCB等待队列都是在共享内存当中维护的, 所以当我们调用唤醒或者等待接口的时候, 就是通过操作共享内存来实现不同进程之间的同步与互斥的
                value: 表实际资源的数量, 用于初始化信号量的资源计数器(随着实际资源的数量变化--停车位 当为0时, 想访问资源的进程或现场就在等待队列中 value = -1, 当停车位+1时, 唤醒队列中的执行流, 然后value+1 = 0)
        3. 等待接口
            sem_wait(sem_t* sem); // 阻塞等待接口
                如果调用该接口, sem_wait函数发现sem信号量当中的资源计数器大于0, 则对资源计数器进行减1操作, 该接口返回
                如果发现资源计数器小于等于0, 则对资源计数器进行减1操作, 阻塞等待
            sem_trywait(sem_t* sem); // 非阻塞等待
            sem_tiemdwait(sem_t* sem); // 带有超时时间的等待

        4. 唤醒
            int sem_post(sem_t* sem);
                发布信号量, 表示资源使用完成了, 需要归还资源或者生产者重新生产了一个资源, 需要对资源计数器进行加1操作,唤醒PCB等待队列当中的PCB
        5. 销毁接口
            int sem_destory(sem_t* sem);

    4. 如何保证同步和互斥
        互斥:
            初始化资源计数器的时候, 初始化资源计数器为1;
        同步:
            初始化的时候, 根据资源的数量来进行初始化信号量中的资源计数器
    5. 面试高频:
        如果信号的值为10, 有3个线程使用到了信号量, 信号量的计数器值为多少??????????????????
            7
        如果有一个线程调用了唤醒接口, 是否要通知PCB等待队列??????????????????????????????
            否
        当唤醒的时候, 对资源计数器进行加1操作, 
            如果资源计数器的值是大于0的, 则不用通知PCB等待队列
            如果资源计数器的值是小于等于0的, 则需要调整PCB等待队列, 等于0时 ,意味刚有车子从PCB队列中出来占据了唯一的空位,还是需要通知PCB队列的, 说不定里面还有等的车子

    使用信号量来完成生产者和消费者模型(环形队列)
        1. 队列实现的时候, 实现一个环形队列(用数组[]来实现) 读和写都是从0号下标开始, 遍历数组用两指针(读到什么位置/写到什么位置)
            保证读的时候, 数组中已经写了;  如果没有写,则读阻塞, 但是可以写
                标记下一个要读/写的位置 pos = (pos + 1) % 数组容量
        2. 生产线程 + 消费线程
        3. 保证同步和互斥(初始化一个信号量)
            互斥:
                sem_t lock_: sem_init(&lock_, 0, 1); 同一时刻只有一个线程可以获得lock的信号量
            同步:
                生产者:
                    sem_t write_sem_; sem_init(write_sem_t, 0, 数组的容量);
                消费者:
                    sem_t read_sem_;  sem_init(read_sem_t, 0, 0); 刚开始初始化时, 数组中为0
            读:
                sem_wait(&lock_);                 ---- 互斥
                sem_wait(&read_sem_);             ---- 同步
                    1. 读数组中的元素内容
                    2. 更新下一次读的位置
                sem_post(&write_sem_); 通知write来写
                sem_post(&lock_);
            写:
                sem_wait(&lock_);
                sem_wait(&write_sem_); 
                    1. 往数组中写
                    2. 更新下一次写的位置
                sem_post(&read_sem_); 通知read来读
                sem_post(&lock_);

        问题: 同步和互斥的调用顺序可以随意吗??????????????????





            

                    
