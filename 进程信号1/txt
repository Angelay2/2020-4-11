信号量:
    system V版本信号量:(并不能支持跨平台)
        1. 本质: 是一个计数器(保存资源数量)+PCB等待队列(存放被阻塞的进程的PCB)
        两个进程都想去访问临界资源(共享内存当中保存了一个变量shm_cout = 10), 一旦涉及到修改变量shm_cout, 容易造成数据二义, 要访问依赖CPU, 帮我们进程A和进程B计算, A拿着CPU去计算,先从共享内存读出变量的值, 放到寄存器当中, 寄存器 = 10, 想要执行10 + 1, 但被打断了,A把CPU让出来了, B拿去计算, 完成对变量的++, 又把CPU让出来, A要用CPU计算,得先恢复现场, 而且寄存器的值还是10, ++后shm_cout变成11, 又回写到共享内存中,
        理论情况下, 进程A+1了, 进程B也加1了, 对于shm_cout理论上值应为12, 但是由于进程A在+1时被打断了, 导致shm_cout的值为11,
        方案:
            在访问临界资源之前, 先去获取一个信号量, 这样的一个信号量中有两个量(计数器和PCB等待队列), 若资源中变量数变为2 ,则计数器的值+1也为2, 要拿信号量,需要对我们的计数器进行预减操作, 1 --> 0,如果计数器的值大于等于0(x-1>=0),x>=1,>0, 也就意味着资源是有空闲的, 我们进程是可以去获取资源的(对计数器减1, 访问临界资源), 如果/当计数器的值是小于0的, 也就意味着资源不是空闲的, 进程不可用访问资源, 如果这个时候还需要访问资源, 则将该进程的PCB放到PCB等待队列中, 当进程A把资源归还给共享内存时,  将计数器当中的值进行+1, 然后唤醒PCB等待队列中的进程B
    如何保证互斥:
        只需将信号量当中的计数器的值设置为1, 也就是意味着同一个时刻只有一个进程可以访问临界资源(要想访问 必须先让计数器预减1), 同一时刻一个进程只能拥有一个信号量


进程信号:
    1. 信号的基本概念
        信号是一种软件中断, 当一个进程收到一个信号的时候, 信号就会打断当前进程, 处理不处理取决于内核(我们), 死了怪自己 
            红绿灯,释放的信号促使我们等待和通过, 通过这样的信号给我们传递信息, 撞死不负责任(只是告诉信息,并没有拉住你) --> 软件中断
        信号的种类:
            linux操作系统中有62个信号(kill -l), 
                前31个(1-31): 不可靠信号, 非实时信号, 信号有可能会丢失,
                后31个(34-64): 可靠信号, 信号不会丢失
    2. 信号的产生方式
        硬件产生:
            ctrl + c: 给进程发送SIGINT信号, 这样的一个信号会导致进程退出;  kill +信号序号 + 进程号
            ctrl + z: 给进程发送SIGTSTP信号, 让一个前台进程放到后台, 并且进程状态为T, 暂停状态
            ctrl + |: 给进程发送SIGQUIT信号, 产生coredump文件, 从键盘退出

        软件产生:
		    1. int kill(pid_t pid, int sig); 包含signal.h头文件                                                                 
                 pid: 相应发送信号给哪一个进程
                 sig: 给自己发送什么信号, 信号序号
            2. void abort(void)
                abort函数, 谁用谁退出
            3. unsigned int alarm(unsigned int seconds), 
                触发之后接收到SIGALRM信号, 在几秒后执行这个信号
    3. 信号的原理
        信号注册
            1. 非可靠信号
                第一次注册
                    更改sig位图当中信号对应的比特位, 就是将对应的比特位由0置为1, 在sigqueue队列中添加相应信号的处理节点(包含该信号将要处理的行为);
                再次注册
                    背景: 意味着还没有来得及处理已经注册的非可靠信号, 这时进程又收到了同样的非可靠信号, 
                    1. 先判断对应信号的比特位是否为1, 如果为1, 则不会添加sigqueue节点到sigqueue队列中,
     这就是为什么1-31是非可靠信号, 就是由于再次注册的时候会判断是否已经有该信号了, 如果有, 则丢弃新来的信号(就没有做任何新的处理)
            2. 可靠信号
                第一次注册
                    更改sig位图当中信号对应的比特位, 就是将对应的比特位由0置为1, 在sigqueue队列中添加相应信号的处理节点(包含该信号将要处理的行为);
                再次注册
                    1. 判断信号对应的比特位是否为1, 如果为1, 则不修改比特位; 如果为0, 则修改为1
                    2. 修改完比特位后, 还需要添加对应的sigqueue节点到sigqueue队列当中去, 不管sigqueue当中是否有相同的可靠信号的sigqueue节点.
            3. 小结:
                    非可靠信号当进程还没处理非可靠信号的时候,信号又多次注册,但我们不会添加sigqueue节点
                    可靠信号,当进程还没有处理可靠信号的时候, 可靠信号又多次注册, 会依次添加sigqueue节点
                当进程在处理信号时, 是根据sigqueue队列当中的节点来依次处理的, 所以
                    非可靠信号注册多次, 只会处理一次
                    可靠信号注册多次, 会处理多次
                位图中比特位清零的情况是信号的注销(就是进程处理完信号之后才会清零), 置为0, sigqueue节点也就出队了,再来个同样信号, 比特位置为1, sigqueue节点入队, 
                
        信号注销过程:
                非可靠信号的注销:
                    将sig位图当中对应信号的比特位置为0, 并且将sigqueue队列当中对应信号的sigqueue节点进行出队操作
                        出队操作: 内核执行相应信号的处理方式
                可靠信号的注销:
                    1. 判断对应信号在sigqueue队列当中的节点数量, 
                        如果信号节点数量等于1, 将sig位图当中对应信号的比特位置为0, 并且将sigqueue队列当中对应信号的sigqueue节点进行出队操作
                        如果信号节点数量等于大于1, 就不能将对应信号的比特位置为0(还是为1), 将对应信号的一个sigqueue节点进行出队操作
    4. 信号的捕捉
    信号处理器程序（也称为信号捕捉器）是当指定信号传递给进程时将会调用的一个函数。
    调用信号处理器程序，可能会随时打断主程序流程。内核代表进程来调用处理器程序，当处理器返回时，主程序会在处理器打断的位置恢复执行。
        1. 信号都有哪些处理方式?
            默认处理方式: SIG_DEL
            忽略处理方式: SIG_IGN ~~ 不干任何事情
                面试题: 当一个子进程退出的时候, 为什么会形成僵尸进程???
                之前: 进程退出的时候, 父进程来不及回收子进程的退出信息, 导致子进程的退出信息(PCB)还在内核当中
                反问: 为什么来不及回收?????
                答案: 子进程退出的时候 会给父进程发送SIGCHLD信号, 而操作系统定义SIGCHLD信号的处理方式为忽略(不会儿子)
            自定义处理方式: 程序员自己定义信号的处理函数
                typedef void(*signhandler_t)(int)
                sighandler_t signal(int signum, sighandler_t handler); 
                    signum: 哪一个信号需要重新自定义
                    handler: 
                        sighandler_t 是一个函数指针, 接收的是没有返回值(void), 有一个int类型参数的函数地址(也就是自己定义的函数)
                        int参数表示说: 哪一个信号触发了内核调用该自定义处理函数, 传递给自定义信号那个触发他的那个信号的值(序号)

    理解自定义信号处理方式
       struct task_struct这个结构体有struct sighand_struct* sighand结构体指针 --> 指向struct sighand_struct结构体 --> 里面有struct k_sigaction action[_NSIG]数组 --> action[xxx]这个数组中的每一个元素的类型都是struct k_sigaction --> 这是一个结构体类型, 这个结构体中还有struct sigaction sa这样的结构体变量, --> struct sigaction也是一个结构体, 这个结构体中有_sighandler sa_handler这个变量 ---> 而这个_sighandler其实就是typedef void(*sighandler_t)(int); ---> 所以sa_handler这个变量是一个函数指针, 他保存的就是函数地址,即就是在sa_handler当中保存信号的处理函数地址, --> action[xxx]这个数组里有很多元素,对应了62个信号 每个方式的处理方式,
       所以当用户调用signal函数更改信号的自定义处理函数的时候, 其实就是更改掉了sa_handler中保存的处理函数的地址(更改为我们现在的自定义函数的地址 而不是之前的处理函数) sa_handler当中保存信号的处理函数的地址, 这个地址决定最终的执行方式 决定sigqueue节点是否出队

    那么所有的信号都可以自定义处理函数吗? ? ? ? ? ? ? ? ? ?
    答案: 
        不是的, 9号信号(SIGKILL)是不可以自定义信号处理函数的; 
                19号信号也是不可以自定义信号处理函数的

    遗留问题:
        int sigaction(int signum, const struct signaction* act, const struct signaction* oldact)
    signal函数本身没有阻塞作用, 我们只是更改了sa_handler里面保存的地址, 更改完成之后就退出了; 但是如果signal函数中加入一个循环, 当收到一个信号后, 内核去调用sigcb(我们自己定义的函数), 导致当前执行流被中断, 
    sigaction函数有阻塞的功能，同时也可以自定义心寒的处理函数的; 比如SIGINT信号来了，进入信号处理函数，默认情况下，在信号处理函数未完成之前，如果又来了一个SIGINT信号，其将被阻塞，只有信号处理函数处理完毕，才会对后来的SIGINT再进行处理，同时后续无论来多少个SIGINT，仅处理一个SIGINT，sigaction会对后续SIGINT进行排队合并处理。

    5. 可重入&不可重入
        

