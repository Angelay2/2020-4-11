高级IO
    1. 在简历或者面试过程当中不要提及自己学过高级IO的知识, 应该在面试当中称之为典型IO模型
    2. 涉及到的知识:
        1. 几种典型IO模型
             同步IO, 非阻塞IO, 异步IO, 信号驱动IO, 
        2. 多路转接IO模型
            select模型, poll模型, epoll模型
        3. IO的过程
           1. 等待IO就绪
                相当于想要获取的资源已经准备好了, 可以进行操作
                读: recv(sockfd, buf, sizeof(buf) - 1, 0)/recvfrom从tcp的接收缓冲区中拷贝数据到buf来, 以及接收多少数据, 必须是对端发送数据给我们了 我们的接收缓冲区当中才会有数据, 如果没有数据 就会阻塞等待, 而在等待接收缓冲区当中有数据到来的这个过程就是等待IO就绪
                写: send/sendto  写阻塞掉时, 等待发送缓冲区当中有空间,, 这也是等待IO就绪的过程
            2. 拷贝数据到缓冲区当中, 
                读: recv(sockfd, buf, sizeof(buf) - 1, 0)/recvfrom从tcp的接收缓冲区中拷贝数据到buf来, 以及接收多少数据, 必须是对端发送数据给我们了 我们的接收缓冲区当中才会有数据, 如果没有数据 就会阻塞等待, 而在等待接收缓冲区当中有数据到来的这个过程就是等待IO就绪                      ------>   将接收缓冲区当中的和数据拷贝到buf当中, 
                写: send/sendto  写阻塞掉时, 等待发送缓冲区当中有空间,, 这也是等待IO就绪的过程,将应用层中的数据, 拷贝到发送缓冲区当中, 


1. 阻塞IO
    1. 资源不可用的情况下, IO请求一直被阻塞直到资源可用,
            用户空间 发起recv调用(IO调用), 内核空间判断接收缓冲区中是否有数据 (等待IO就绪过程), 如果IO就绪了, 就会拷贝数据到缓冲区当中, 如果几首缓冲区当中没有数据, 就没有办法给buf当中拷贝数据, 如果有,则拷贝,拷贝完成后,recv返回(IO调用返回)
    2. 钓鱼的时候, 将鱼钩泡入到水中(发起IO调用), 眼睛一直盯着鱼漂(等待IO就绪), 有鱼儿咬勾(IO就绪),将鱼钓上来(拷贝数据到缓冲区当中)
    3. 阻塞IO的特点
        1. 发起IO调用之后,等待的时间取决于内核; 直到IO调用才可以执行其他代码, 否则就一直在执行内核代码,和我们没关系
        2. 在等待的过程当中, 执行流是被挂起的, 对CPU的利用率是很低的,
        3. 在IO就绪到拷贝数据之间, 实时性是很高的, IO一就绪,就拷贝到缓冲区了
        4. 代码编写起来比较简单(只需要发起IO调用, 其他步骤都是内核完成(等待就绪,拷贝))
2. 非阻塞IO
    1. 资源不可用的时候, IO请求不会被阻塞,而是直接返回,返回当前资源不可用(EBUSY);
        如果当资源不可用的时候, IO请求返回之后, 表示本次IO请求并没有真正完成,所以想要完成IO请求,非阻塞IO需要搭配循环使用, 直到完成IO请求; 如果资源不可用, 就直接返回到用户空间, 没有真正执行IO请求;
        发起IO调用, 资源还没有准备好, IO没有准备就绪,就会返回EWOULDBLOCK(IO调用直接返回),
        返回之后, 当第二次再去发起IO调用, 发现还没准备好, 又直接返回
        第三次再去发起IO调用, 党内和发现资源已经准备就绪,拷贝数据到缓冲区当中, 一拷贝, 这个IO请求就真的被执行了 调用返回
    2. 例子:  钓鱼的时候, 将鱼钩泡入到水中(发起IO调用), 看一眼鱼漂, 鱼漂没动, 则刷一会抖音, 再看一眼, 鱼漂没动, 再刷抖音, 如此往复, 直到鱼钩被咬(资源准备就绪), 将鱼钓上来(返回).
    3. 非阻塞IO特点:
        1. 非阻塞IO对CPU的利用率比阻塞IO高,
        2. 代码复杂, 流程控制复杂 , (因为需要循环的缘故)
        3. 需要搭配循环调用, 直到IO请求完成
        4. IO准备就绪到数据拷贝之间, 不够实时
        while(非阻塞调用){
            // 用户代码1
            // 用户代码2
            ....
        }若刚一返回, 资源就准备好了, 可是我们却在这里执行用户代码, 下次进入循环时, 才发现资源已准备好, 但是IO就绪到数据拷贝之间已经等待了很长时间
    小结:
        在资源不可用的情况下, 只需要关心IO是否立即返回, 没有立即返回, 则说明是阻塞, 立即返回则说明是非阻塞

3. 信号驱动IO
    1. 实现流程
        1. 自定义一个IO信号(SIGIO 29号)的处理函数, 在处理函数当中发起IO调用, 
        2. 程序收到一个IO信号(意味可以读数据可以写数据了), 内核就会调用自定义处理函数,内核调用了自定义调用函数,
             自定义信号处理函数(signal, sigaction函数), 一调用就直接返回了(信号处理方式改变完成), 假设改了SIGNO-->sigcb(int signo) ,改了之后, 内核完成等待IO就绪, 以及就绪之后发送信号, 最后执行时就只需要拷贝数据了
    sigcb(int signo){
        // 发起IO调用
    } 当我们程序现在收到一个IO信号, 才会在自定义处理函数内部会发起IO调用, 省略了等待IO就绪, 只剩下直接拷贝数据到缓冲区
    2. 例子:
        在鱼竿上帮一个铃铛(自定义处理函数), 将鱼钩泡入水中(内核等待IO就绪) , 接下来就可以干自己的事情了, 鱼钩咬勾只够, 铃铛就会响(收到IO信号,处理函数, 发起IO调用), 这时候就将鱼儿调上来
    3. 特点:
        1. IO准备就绪, 到拷贝数据之后, 实时性增强了(铃铛一响, 我们就直接钓上来了)
        2. 代码更加地复杂, 流程控制更加困难, (因为引入了信号)
        3. 好处是不需要重复发起IO调用, 但是需要在代码当中增加自定义信号的逻辑

4. 异步IO
    1. 原理
        1. 自定义信号(SIGNO)处理函数 ---> 通知数据拷贝完成的一个作用
        2. 发起一个异步IO调用, 异步IO调用会直接返回(到用户空间)
        3. 异步IO调用返回之后, 执行流可以执行用户代码, 由操作系统内核去完成等待IO就绪和数据拷贝
        4. 当数据拷贝完成, 内核通过信号来通知调用者
    2. 例子:
        钓鱼的时候, 带着媳妇(自定义一信号处理函数), 告诉媳妇当鱼钓上来之后通知我(发起异步IO调用, 我立即返回), (我就可以干其他事情了), 媳妇去钓鱼, 当媳妇钓上来鱼之后通知我(通过信号来通知我), 我就可以直接拿着鱼进行操作.
        首先定义一个信号(用signal/sigaction函数),信号处理方式改变完成,发起异步IO调用,立即返回, (操作系统内核完成1. 等待IO就绪 2.拷贝完成之后,通知调用者)
    3. 公司使用异步IO
         1. 发起异步IO调用
         2. 异步IO调用就返回了, 当前执行流就可以干其他事情了
         3. 等待异步IO调用完成, (异步IO函数接口当中一般会设置一个函数指针来保存IO调用完成之后通知调用者的回调函数)
    4. 小结:
        同步IO, 相当于发起IO调用后, 需要等待获取结果
        异步IO, 相当于发起IO调用后, 不需要直接等待获取结果, 而是通过回调函数的方式返回给调用者
        异步IO最大的特点是用户不需要拷贝数据了, 拷贝数据也被操作系统内核完成了, 完成拷贝之后, 通知调用 

多路转接IO模型
    1. 作用: IO多路转接可以完成大量文件描述符的监控, 监控的事件包含可读事件/可写事件/异常事件
    2. 监控文件描述符, 哪个文件描述符有时间就绪, 就处理哪一个文件描述符
    
    select
        1. 实现流程
            1. 将用户关心的文件描述符拷贝到内核当中, 内核来进行监控
            2. 如果内核监控到了某个文件描述符, 则返回该描述符
            3. 用户针对返回的描述符进行操作
        2. 接口
            int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
                nfds: 取值为监控最大的文件描述符取值 + 1 ;
                fd_set: 称之为事件集合, 本质上是一个位图
                    typedef struct{
                        _fs_mask fds_bits[_FD_SETSIZE/_NFDBITS];
                    }fd_set;  (源码)
                        
                        _FD_SETSIZE: #define _FD_SETSIZE 1024
                        _NFDBITS: #define _NFDBITS (8*(int)sizeof(_fd_mask))  
                            这两个可以得到数组的元素个数: 1024/8*(int)sizeof(_fd_mask)
                        _fd_mask:  typedef long int_fd_mask;
                            可以得到数组当中比特位的个数: (1024/8*(int)sizeof(_fd_mask))*8*(int)sizeof(_fd_mask) = 1024
                
                结论: select的事件集合总共有1024个比特位, 取决于宏_FD_SETSIZE这个宏, 在事件集合中最多能置1024个比特位, 最多帮我们监控1024个事件.
                当想要知道监控哪一个比特位需要知道:
                    1. 比特位的下标对应的文件描述符的数值(如果想要监控0号文件描述符,则将位0的比特位置为1, 如果想要监控8号文件描述符,则将8号位置为1)
                三个位图对应的是不同的事件,
                    可读集合: 如果关心文件描述符的可读事件, 则将该文件描述符添加到可读事件集合当中去
                    可写集合: 如果关心文件描述符的可写事件, 则将该文件描述符添加到可写事件集合当中去
                    异常集合: 如果关心文件描述符的异常事件, 则将该文件描述符添加到异常事件集合当中去
                    添加文件描述符到事件集合当中的含义就是将文件描述符对应的比特位置为1
                操作fd_set集合, 操作系统提供了4个函数:
                    void FD_CLR(int fd, fd_set *set); // 从事件集合当中删除文件描述符fd, 描述符对应的比特为置为0
                    int FD_ISSET(int fd, fd_set *set); // 判断fd描述符是否在set集合当中, 
                                                            返回值: 0表示没有在集合当中; 
                                                            非0: 表示在集合当中
                    void FD_SET(int fd, fd_set *set); // 将文件描述符fd设置到set集合当中, 描述符对应的比特位置为1
                    void FD_ZERO(fd_set *set); // 清空事件集合, 将所有比特位置置为0
                内核进行监控的时候是按照nfds(传进去)这个范围来进行监控的, 挨个轮循往后监控是否就绪(轮循的范围由nfds来决定)
                
                timeout: 超时时间
                    timeout == NULL ; // 阻塞监控,没有文件描述符返回, 就一直阻塞
                    struct timeval{
                        long tv_sec; 秒级单位
                        long tv_usec; 微妙级
                    }
                    timeout == 0;  非阻塞监控(tv_sec == 0, tv_usec == 0)
                    timeout > 0; 带有超时时间监控了 到了超时时间就自然返回了
                返回值: 
                    大于0: 返回就绪的文件描述符个数
                    等于0: 等待超时了(timeout > 0)
                    小于0: 监控出错了
                select: select返回的时候, 也会返还集合, 同时将未就绪的文件描述符给从集合中去掉, 只返回就绪的文件描述符

    select结合tcp如何去使用:
        tcp的服务端的编程流程
            1. 创建套接字
            2. 绑定地址信息
            3. 监听
            4. 获取新连接
            5. 接收数据
            6. 发送数据
            7. 关闭连接
        select编程流程
            1. 准备对应的时间集合并清空
            2. 将对应的文件描述符添加到事件集合当中
            3. 监控
            4. 处理监控结果
                 监控出错
                 监控超时
                 监控到文件描述符就绪
            可以监控侦听套接字(和获取连接相关, 新连接对应新的文件描述符,又对应接收数据和发送数据)
           
           1. 创建套接字
           2.  绑定地址信息  
                1. 准备对应的时间集合并清空, 
                2. 添加侦听套接字到事件集合当中
                3. 监控
                4. 处理监控结果(若检测到对应文件描述符就绪, 则获取新连接)
                    添加新的套接字到事件集合当中去,
                    继续监控(又检测到有对应的文件描述符时, 此时既有侦听套接字还有新创建的套接字, 因此需要判断是哪一个描述符就绪, 判断完后,才去执行相应的动作
                    若是新连接: 则有新数据到来, 发送数据和接收数据
                    若是侦听套接字 则获取新连接)

            3. 监听





