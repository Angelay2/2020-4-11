传输层 ----> UDP , TCP
    无传输,不可靠,面向数据报
面向数据报:
    应用层在使用UDP的时候,程序员 从UDP接收缓冲区当中拷贝数据 或者 将应用层数据拷贝到UDP的发送缓冲区 当中,都是一整条UDP报文进行拷贝的,不会存在两条数据并存在缓冲区当中,
    UDP协议头部:
    struct udphdr{
        uint16_t uh_sport; // s->source port->端口 源端口
        uint16_t uh_doprt; // 目的端口
        uint16_t uh_ulen; // udp数据报长度
        uint16_t uh_sum; // udp的检验和
    }
    数据报长度:
        类型是uint16_t,
        最大表示的数值为2^16=65536
        单位是字节
        udp数据长度所能表示的范围是0~65536个字节
        UDP协议头部+UDP有效载荷(应用层递交给UDP的数据) <= 65536字节
    1. 使用UDP传输100k的数据可以吗? (说明数据在应用层,)
        65536 -> 64k, 100k一次传不完,一次最多只能传64k, 
        但是是可以的,
        应用层UDP: 需要使用自定义协议,需要将100k完整数据传输到对端,也是100k
        传输层的UDP: 50k+传输层的udp报头通过网络传输到对端,递交给对端的应用层,去掉报头, 最终两个都到对端的应用层, 若要使数据完整,得在应用层的UDP给两个50同时打上相同的标识,到对端的应用层后再拼凑.
    udp校验和:
        判断UDP数据在传输过程当中是否有损坏;
        如果有损坏的话,则不会将数据递交给应用层,直接丢弃; (不可靠的地方 体现)
        如果没有损坏, 则将数据递交给应用层, 应用层需要调用recvfrom
    校验和的工作原理:
        16个比特位相加(2进制相加)再取反码放到校验和,到对端在16位 16位拆开,如果是全1,则数据正常

    UDP缓冲区:
        1. 对于应用层的数据是整条数据接收和发送的,
        2. UDP协议在传输层也是有发送缓冲区的,只不过当应用层调用sendto之后将数据递交给UDP的发送缓冲区之后,在缓冲区当中加上UDP协议的报头之后,就直接递交给网络层
        3. 对于接收缓冲区而言, 应用层调用recvfrom函数, 从接收缓冲区当中获取数据
    UDP的应用:
        1. DNS协议(应用层协议): 域名解析协议, 底层使用UDP
        2. DHCP协议: 动态主机分配协议 (谁上网给水分配IP地址) 台式和笔记本谁先连接路由器开始使用, 谁先分配到IP地址,
            由于现在使用的ipv4的IP地址不够, 谁上网我去给谁分配IP, 且不能重复
            udp广播: 目的IP地址, 255,255,255,255(其他所有的主机都可以收到,但是只有路由器可以处理)

传输层的TCP协议:
    1. 特性: 面向连接, 可靠传输, 面向字节流
    面向连接:
        问题: 谈谈你所理解的三次握手(在内核建立)\
            客户端调用connect接口(socket,connect),向server发出SYN连接,client自身的状态变为SYN_SENT, server建立完连接(socket,bind,listen),等客户端来连接他, server的状态变成SYN_RCVD, 需要告诉client(ACK(回复刚才的SYN)+SYN(服务端发给客户端的连接请求)),客户端收到连接后变成ESTABLISH(连接已建立),两次握手完毕,对于服务端不知道客户端是否收到连接,需要等待客户端给服务端回复ACK(回复刚才的SYN)server收到ACK后,状态也变成ESTABLISH,达成三次握手.
        1. 发生数据包的名称
        2. 配合客户端和服务端的状态来进行描述
        3. 包序管理 服务端需要调用accept函数来接收上述三次握手已达成, 
    服务端通过accept来接收三次握手是否完成
    客户端通过send发送数据, 服务端确认收到数据
    确认的行为是参数从TCP协议的行为, 而不是应用层的行为,
    recv函数从接收缓冲区接收数据
    服务端send发送数据给客户端(PSH),客户端确认收到数据(ASK),
四次挥手:(不想连接了)
    谁调用close接口 会给对端发FIN, 两个人都有权利主动断开连接, 谁先调用close谁是主动,发送后自身接口变成FIN_WAIT_1, 对端收到后变成CLOSE_WAIT,回复ACK,主动断开连接方变成FIN_WAIT_2, 此时对端再次给主动断开连接方(FIN), 对端变LASK_ACK, 主动方接收到FIN报文后,自身变TIME_WAIT, 回复ACK, 被动连接方接收到ACK后,状态变CLOSED. 自身变成CLOSED状态/(分手 别告知要分手,缓了一会 再回复)
    MSL: 最大报文段生存时间,发送方认为TCP报文在网络当中的最大生存时间,
    2MSL: 指的是有可能丢失的ACK的MSL + 重传的MSL   若在传送ACK的时候丢失了ACK,要是超过了一定时间后对端超时重传,则对端会再次发送FIN,状态依旧是LASK_ACK,主动端发送了ASK后等待了2MSL没有收到对端回复的话,就变为CLOSED, 若是
   
   如果说连接处于TIME_WAIT状态,是否还可以接收数据包???
        可以接收数据包,意味着端口并没有释放,
        如果主动断开连接方式(为客户端), 意味着客户端会有TIME_WAIT状态,             多对1
        如果主动断开方是服务端, 意味着服务端会有TIME_WAIT状态
            如果现在连接处于TIME_WAIT状态,意味着端口还没有被释放,
            如果服务端关闭掉套接字并且程序退出了,但是有可能刚刚程序监听的端口还在传输层被占用着; 原因是连接还处于TIME_WAIT状态,需要等待2MSL的时间,才能释放端口
            在处于TIME_WAIT的时候就想要绑定之前的端口,(Already in use)
            19999 --> close --> TIME_WAIT(19999)
            一个端口只能被一个进程多绑定, 端口还没有被释放前,你就想要用它,就会出现Address already in use;

地址复用:
    核心思想就是告诉内核, 这个地址信息可以被复用;  
    int setsockopt(int sock,int level, int optname, const void* optval, socklen_t len);
        sock: 将要被设置的套接字
        level: 指定套接字的层次
            SOL_SOCKET: 通用套接字选项 ---> 地址复用
            IPPROTO_TCP: 
            TPPOTO_IP:
        optname: 
            SOL_SOCKET: 通用套接字选项 ---> 地址复用 
                SO_REUSEADDR: 允许重用本地地址和端口
                SO_RECVBUF: 获取接收缓冲区的大小
            IPPROTO_TCP:
                TCP_MAXSEG: 获取最大报文段长度
            IPPROTO_IP:
                IP_TTL: 获取最大的生存时间
        optval: 告诉setsoskopt函数, 具体如何完成我们指定的任务
            地址复用的时候只需要传入1个值就可以了
            在传参的时候, 可以传入int类型的地址(&i)
        socklen_t:
            optval的长度
TCP协议的协议字段:
    16位源端口: 标识数据从哪一个端口来;
    16位目的端口: 标识数据去往哪一个端口
    32位序号: 标识TCP源端向TCP目的端发送的数据字节流
    32位确认序号: 标识TCP目的端期望TCP源端的下一个请求序号
        序号在TCP连接当中是两套序号, 客户端维护一套,服务端维护一套
            客户端给服务端发送数据, 使用的是客户端的序号,服务端确认的时候,确认的是期望客户端维护的序号的下一个序号
            服务端给客户端发送数据, 使用的是服务端的序号, 客户端确认服务端的时候, 期望服务端下一个序号
        三次握手的时候, 连接双方会协商双方序号的起始位置,不一定从1开始,只要后序的序号和之前的序号能够堆上就可以了, 没有对起始序号做要求.

    包序管理器的规则:
        1. 纯ACK数据不占用序号
        2. 确认序号 = 接收到的数据的起始序号 + 数据长度



