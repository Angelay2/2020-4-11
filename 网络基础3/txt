面向字节流:
    字节流: 数据和数据之间是没有明显的界限的,
    接收: 针对应用层程序, 可以指定接收任意大小的数据
        recv(sockfd, buf, sizeof(buf) - 1, 0); (buf是我们自己确定的, 接收多大的字节都可)
    粘包问题:
        应用层头部 + 应用层数据 + 间隔应用层头部 + 应用层数据 + 间隔  (通过间隔找到应用层头部)

1. 谈谈你所理解的三次握手和四次挥手
2. tcp粘包问题能够描述下吗, 怎么解决
3. tcp的可靠传输机制都有哪些
4. 想让udp保证可靠, 应该如何做
5. tcp或者udp协议字段
6. tcp包序管理
7. 滑动窗口机制
8. 拥塞控制机制

网络基础3:
    网络层:
        IP协议(ipv4)报头格式:
            4位版本: 标识IP协议的版本
            4位守护长度: 标识IP协议头部长度, 4个比特位计算出来的数值乘以4, 表示ip头部占用的字节数量(总共60字节, 固定20字节)
            8位服务类型:
                aa. 前面三个比特位表示优先权, 但是已经弃用掉了,
                bb. 后面的4个比特位, 表示 最小延时(ssh)+ 最大吞吐量 + 最高可用性+最小费用: 这四个比特位是一个互斥的关系, 一般情况下, 都是0, 表示默认属性;
                cc. 最后一个比特位, 保留位, 但是必须为0
            16位总长度: 标识IP数据报整体的长度(占用字节的数量)  ---> 2^16
                ip协议头部 + 数据(应用层递交的数据)
                aa. 在网络传输的时候, 网络层的数据是交给数据链路层的, 而数据链路层由于电气的特性, 对传输的数据做了约束, 通过ifconfig可以查看网卡当中的限制, 数据链路层对传输数据大小的限制---> mtu
                    mtu: (最大传输单元) 
                        限制了网络层递交给数据链路层数据包的大小不能超过MTU, MTU的单位为字节;
                        下面网卡当中的MTU为1500字节, 网络层在提交数据的时候不能超过1500字节
                    UDP协议: 
                        a. UDP是整条数据交付的 有可能在提交给网络层数据的时候, 超过了mtu的大小限制, 
                        b. 当网络层的数据超过MTU限制的时候, 需要在网络层进行分片传输, 将超过MTU限制的数据, 分成不同的数据, 通过网络传输搭配对端去,
                        c. UDP协议是不可靠的, IP协议也是不可靠的, 所以如果分片传输, 丢失了一个分片, 则整个数据包Juin被丢掉了
                        结论: 如果UDP数据包长度, 超过了MTU的限制, 则在网络层需要进行分片传输;
                    tcp协议:
                        MSS: 最大报文段长度, 限制tcp提交给网络层数据的长度
                        MTU = MSS + IP头部 + TCP头部
                        TCP协议在传输数据的时候严格按照MSS来给网络层提交数据的, 所以在网络层IP协议拿到tcp提交的数据后, 一定是小于等于MTU - IP头部的( 比如1500-20 = 1480字节 )
                        结论: 由于tcp在传输数据的时候, 严格按照MSS来提交数据, 所以网络层拿到tcp协议提交的数据, 不需要在网络层进行分片传输
            16位标识: 标识当前udp数据包分片数据是属于哪一个完整的UDP报文的, 同一个UDP数据包当中的所有分片具有相同的标识值.
                (tcp不需要分片)
                应用层: 假设有2500字节数据, sendto()到传输层 
                传输层: 直接传输给网络层,
                网络层: 2500 + udp头部(8个字节) = 2508  --> 进行分片 1480 然后再加网络层的报头20 = 1500, 剩下1028字节(第二个字节, 也加20字节报头传给数据链路层)
                数据链路层: 这里有限制(MTU 1500)
                物理层:
                当传输到对端后, 发现前者和后置的16位标识是一样的, 就会等待后者, 最终一起传输到对端的应用层
            3位标志:
                位1: 保留位
                位2: 禁止分片
                位3: 标识更多分片
                    当该位置为1的时候, 标识该分片不是最后一个分片
                    当该位置为0的时候, 标识该分片已经是整个UDP数据包的最后一个分片了
            13位片偏移: 用来标识分片在原来数据当中的位置, 用于接收方组装数据, 要算片偏移得先用字节数除以8,
				传输层打上报头后,递交给网络层,网络层拿到UDP数据包后发现超过MTU,进行分片,给每一个分片都加上网络层报头 再通过数据链路层, 物理层传送到对端, 发的顺序不一定是到对端的顺序, 网络层的UDP协议并不保证可靠(并不保证包的有序到达), 对端要按照先后顺序去组织,就是13位片偏移干的事情, 在对端网络层组装完毕,
                13位能够表示的数值时2^13 = 8192(是一个数值, 并不是字节)
					表示字节的时候, 需要给数值再乘以8(2^3), 总体相当于2^16字节,
					计算出来的片偏移的数值*8之后得到的字节, 标识分片的起始位置.
			8位生成时间:
				数据在传输到目的地之前允许经过的路由器的个数,
				TTL: 跳数, 描述数据包可以最大经历多少路由器转发, 每经过一个路由器, 该TTL进行减1操作, 
					1. 直到减为0, 还没有到达目标主机, 该数据包就被转发设备丢弃了
                    2. 在减为0之前, 到达了目标主机,完成传输,
                预防了由于网络的循环路由, 导致数据包在网络当中一直循环路由, 减轻转发设备的压力,
                TTL一般情况下为64, 
            8位协议: 标识传输层使用什么协议, 在数据分用的时候, 通过该字段, 将数据提交给想要的协议, 
            16位首部校验和:
                判断IP头部在传输过程当中是否损坏,
            32位源IP地址: 
            32位目的IP地址:  这两个32位地址一般情况下, 在网络传输中是不会改变的, 例外情况: 在NAT技术中会改变

        地址管理:
            1. 目前讨论的IP地址是ipv4版本的IP地址, 无符号的32位的整数, 范围是0~2^32 (IP地址池, 42亿多地址)
            2. 早期划分方式:
                32位的IP地址划分为两个部分 = 网络号(网段) + 主机号, 就能唯一确定哪一地址
                网络号: 标识一个子网络, 网络号就是代表了一堆的IP地址
                主机号: 在子网中唯一标识一台主机;
                A类IP地址: 0.0.0.0 ~ 127.255.255.155
                    32位比特位高一位固定为0, 后面7位为网络号, 24位为主机号,
                    0 0000000 00000000 00000000 00000000 ===>  0.0.0.0(点分十进制)
                    0 1111111 11111111 11111111 11111111 ===> 127.255.255.255
                    A类IP地址的范围为0.0.0.0 ~ 127.255.255.255
                    网络号范围: 0 0000000 ~ 0 1111111 ===> 0 ~ 127, 总共有128个子网, 每个子网中有16777217个IP地址
                    0.0.0.1.002
                    主机号范围: 0 ~ 2^24, 每一个子网当中都有这样的一个主机号范围
                    0 ---> 0~2^24(0 ~ 16777216)
                    1 ---> 0~2^24(0 ~ 16777216)
                B类IP地址: 128.0 ~191.255
                    高两位固定为10. 后面14位标识网络号, 16位标识主机号
                    网络号的范围 10000000 00000000 ~ 10111111 11111111  ---> 128.0 ~ 191.255 (后者减去前者就是子网个数)
                    主机号: 00000000 00000000 ~ 11111111 11111111 ---> 0 ~ 65536( 每个子网中有65536个IP地址 )
                找A类IP地址最大: 127.255.255.255, => 2147483647
                  B类IP地址最小: 128.0 ===> 2147483648     两类是挨着的
                C类IP地址: 192.0.0 ~ 223.255.255
                    高三位固定110, 后面12位标识网络号, 8位标识主机号
                    网络号范围
                        110000000 00000000 00000000 ~ 110 11111 11111111 11111111 ===> 192.0.0 ~ 223.225.225
                    主机号范围:
                        0 ~ 2^8(255)
                D类IP地址:
                    高4位固定, 28位的多播组号
                E类IP地址:
                    高5位固定, 27留用
            
            公司有10台电脑, 10个人想上网, 10个IP -->  C类
                256个IP地址, ===> 200多的IP地址没有用到, 但是又不能给别人

        CIDR方式, 这种方式就是为了更加精确化的划分子网, 
            1. 引入了子网掩码, 在机器向路由器申请IP地址的时候, 路由器不仅给机器动态分配(DCHP)一个IP地址, 还分批了一个子网掩码
            2. 子网掩码的意义:
                最大主机号 === 子网掩码取反
                网络号(网段) == 子网掩码 & IP地址
                inet(IP地址) 172.16.99.129  netmask(掩码) 255.255.255.0 --> 最大主机号为255(主机号的范围就是0 ~ 255)
                相& 后为172.16.99.0 ----> 网络号
            题目: 一个网络当中的网络号为172.16.99.0, 子网掩码为255.255.255.0, 现在需要将该网络平均分为4个子网, 求每个子网当中的IP地址范围,以及子网掩码?
            1. 计算当前子网当中的IP地址数量
                0.0.0.255 --> 最大的主机号为255, 主机号的范围为(0~255), 总共256个IP地址
                256/4 = 64IP地址 ===> 推出第一个子网的主机号范围为0 ~ 63,===> 划分出来的 第一个子网的最大主机号为63
                取反之后的子网掩码: 00000000 00000000 00000000 00111111 ==> 63
                    取反之后有多少位为1, 则表示使用了多少位比特位来表示主机号
                          子网掩码: 11111111 11111111 11111111 11000000 ==> 255.255.2555.192
            2. 求子网的地址范围:
                172.16.99.0 ~ 172.16.99.63       netmask: 255.255.255.192     0 : 00000000
                172.16.99.64 ~ 172.16.99.127     netmask: 255.255.255.192     64 : 01000000
                172.16.99.128 ~ 172.16.99.191    netmask: 255.255.255.192     128: 10000000   主机号全为1的表示广播号
                172.16.99.192 ~ 172.16.99.255    netmask: 255.255.255.192     192: 11000000   主机号全为0的表示网络号
         每一个子网的网络号  ~   每一个子网当中的广播号
                172.16.99.55 & 255.255.255.192 = 172.16.99.0
                55: 00110111
                192: 11000000
                当目的IP是一个广播号时, 经过路由器转发时, 会给子网当中所有机器转发, 

            IP地址是分配给机器使用的
        
    私网: 直接使用不需要报备, 
        从42亿地址池中划分出来3个段的IP地址, 这三个段的IP地址不具备访问互联网的效力, 不能直接访问互联网
    划分出来的三个段当中的IP地址如何使用???
        1. 这三个段当中的IP地址可以不经过申请, 直接被个人或者企业, 国家使用
        2. 这些IP可以被不同的设备进行复用, 这些IP组织的网络称之为私网. 对应的互联网, 我们称之为公网
        3. 私网当中的IP地址, 在私网当中可以与私网当中的机器进行通信, 但是不能与互联网进行通信
        4. 如果私网IP地址需要访问互联网, 需要进行私网网络地址转换, 将私网IP地址通过NAT转化为公网的IP地址, 然后将这条数据包发送到网络;
    私网的网段:
        1. 10.*.*.* ===> (10.0.0.0  ~ 10.255.255.255) ===> 云服务器一般会看到10打头的IP地址
        2. 172.16.*.* ===> (172.16.0.0 ~ 172.31.255.255)  虚拟机中的  ping的时候会被转换位公网IP
        3. 192.168.*.* ===> (192.168.0.0 ~ 192.168.255.255)

    特殊的IP地址,: 
        127.0.0.1 本地回环地址, 用来调用网络协议栈
        0.0.0.0 : 一般用于服务端程序, 表示服务端程序当中所有网卡当中的IP地址
        255.255.255.255 : UDP的广播地址, 全网广播, DHCP
        主机号全为0, 表示网络号
        主机号全为1, 表示子网的广播号,

        路由选择: IP地址出去后是经路由器选择的 路由器就是分析IP地址,转发到相应的机器
            路由器: 有两种类型的口, (电脑查LAN口(eth1虚拟网卡), 网线插WAN口(eth0虚拟网卡)--> 连接上级的LAN口, 上级的WAN连接互联网
            口中也有网卡, 也有对应的IP地址, 
            route命令后: 
                目标网络       默认网关  子网掩码  标志位  网卡信息
                Destination     Gateway   netmask   Flags   Iface
            标志位下:
                U: 该路由项是有效的
                G: 该路由项是网关
                 先拿到数据当中的目的IP和子网掩码相& 后与目标网络进行比对, 如果符合, 就通过网卡发出去, 转发到本地的相应机器, 如果不符合就交给默认网关,转发给上级路由网关, 如此往复
                每经过一个路由器 TTL都减1, 直到TTL为0. 要是还没到目的IP, 那这条数据就会被丢弃
                在每一个路由器上进行比对
